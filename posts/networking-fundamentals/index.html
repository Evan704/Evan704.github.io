<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>网络基础 | Evan's blog</title><meta name=keywords content="网络安全,Basics"><meta name=description content="介绍了网络的核心组件和网络安全的基础内容"><meta name=author content><link rel=canonical href=https://evan704.github.io/posts/networking-fundamentals/><meta name=google-site-verification content="einQoik8Jc69jO4Z7q6ltdiWgaJkeVfOOjYYzNlWg7E"><link crossorigin=anonymous href=/assets/css/stylesheet.4c6f69b34a762cc229b9ad1eeb68c3438e4bc181b8a031758026adf7a05922c2.css integrity="sha256-TG9ps0p2LMIpua0e62jDQ45LwYG4oDF1gCat96BZIsI=" rel="preload stylesheet" as=style><link rel=icon href=https://evan704.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://evan704.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://evan704.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://evan704.github.io/apple-touch-icon.png><link rel=mask-icon href=https://evan704.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://evan704.github.io/posts/networking-fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><link rel=stylesheet href=/css/syntax.css><meta property="og:url" content="https://evan704.github.io/posts/networking-fundamentals/"><meta property="og:site_name" content="Evan's blog"><meta property="og:title" content="网络基础"><meta property="og:description" content="介绍了网络的核心组件和网络安全的基础内容"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-01T11:49:25+08:00"><meta property="article:modified_time" content="2025-07-01T11:49:25+08:00"><meta property="article:tag" content="网络安全"><meta property="article:tag" content="Basics"><meta name=twitter:card content="summary"><meta name=twitter:title content="网络基础"><meta name=twitter:description content="介绍了网络的核心组件和网络安全的基础内容"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://evan704.github.io/posts/"},{"@type":"ListItem","position":2,"name":"网络基础","item":"https://evan704.github.io/posts/networking-fundamentals/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"网络基础","name":"网络基础","description":"介绍了网络的核心组件和网络安全的基础内容","keywords":["网络安全","Basics"],"articleBody":"IP地址\u0026子网掩码 IP地址：网络世界里的“门牌号”，唯一标识一台设备。最常见的是IPv4格式，如 192.168.1.10，它实际是一个32位的二进制数，为方便阅读写作4个十进制数（每个表示8位二进制数）。 分类： 公网IP (Public IP)：全球唯一，由运营商分配，可以直接在互联网上访问。 私网IP (Private IP)：在一个局域网内唯一，不能直接在互联网上访问。 一个IP地址并非一个整体，它包含两部分信息：网络ID和主机ID。计算机如何知道哪部分是网络ID，哪部分是主机ID呢？答案是利用子网掩码。 子网掩码：用于区分网络ID和主机ID。1部分标识网络ID，0部分标识主机ID，如255.255.255.0表示前24位为子网地址，后8位为主机地址，也可以用/24表示。 例： IP地址: 192.168.1.10 子网掩码: 255.255.255.0 那么网络ID是前24位：192.168.1，主机ID是后8位：10，所有192.168.1.x的设备都在同一个局域网内，它们之间可以直接通信。 子网划分 想象一个有500台电脑的大公司，如果它们都在同一个局域网内，任何一台电脑发送一个广播（比如寻找打印机），所有500台电脑都会收到，网络会非常拥堵。子网划分就是将一个大的网络，切分成若干个互不干扰的小网络（子网），比如“财务部子网”、“技术部子网”。怎么实现这一点呢？我们可以通过修改子网掩码，向主机ID“借”几位，把它们变成子网ID。\n举个例子，我们有一个网络192.168.1.0，原本的子网掩码是255.255.255.0，这个局域网下，我们有$2^8-2=254$个可用的主机IP。如果我们想把它们分成两个网络，我们可以向主机ID借一位，新的子网掩码就是255.255.255.128，这样我们就得到了两个子网，192.168.1.0和192.168.1.128\nTCP 与 UDP TCP 和 UDP 负责将数据包送到正确的端口。\nTCP (Transmission Control Protocol) - 可靠的信使 TCP 的特点是可靠且能进行流量控制。TCP 在发送数据前，必须先建立连接。这就是著名的“三次握手”。\n三次握手 客户端 -\u003e 服务器：发送一个SYN包。“你好，我想和你建立连接，我的初始序列号是X。” 服务器 -\u003e 客户端：回复一个SYN/ACK包。“好的，我收到了你的请求。我同意连接，我的初始序列号是Y，我确认收到了你的序列号X。” 客户端 -\u003e 服务器：再次发送一个ACK包。“好的，我收到了你的确认。现在连接正式建立，我们可以开始通信了。” UDP (User Datagram Protocol) - 迅捷的信使 UDP 的特点是不一定可靠，但速度更快。UDP 在发送数据前不需要建立连接，直接发送。它的适用场景是对实时性要求高，但能容忍少量丢包的场景，比如视频直播和在线游戏。\n端口 端口的作用是区分一台主机上的不同应用。IP地址让数据找到电脑，端口号让数据找到正确的程序。范围：0 - 65535。\n常见端口：\nFTP: 21 (TCP) SSH: 22 (TCP) SMTP: 25 (TCP) DNS: 53 (UDP为主，TCP为辅) HTTP: 80 (TCP) HTTPS: 443 (TCP) DNS（域名服务器） 计算机在网络中互相寻找，靠的是IP地址（如142.250.72.142）。但人类显然更擅长记忆名字（如www.google.com）。DNS (Domain Name System) 的核心使命，就是负责在这两者之间进行双向翻译。\n当你输入一个网址时，你的电脑并不知道www.google.com在哪里。它必须先通过DNS查询，获得其对应的IP地址，然后才能向该IP地址发起网络连接。\n一次完整的域名解析过程如下：\n本机缓存：的电脑会先检查自己的“小本本”（DNS缓存）：“我最近查过这个域名吗？”。如果查过且没过期，就直接使用缓存的IP地址，查询结束。同时，它也会检查一个特殊的hosts文件，这个文件允许你手动指定域名和IP的对应关系，优先级很高。 本地DNS服务器：如果本机没有缓存，请求会被发往你的本地DNS服务器。这通常是你的ISP（运营商，如电信、联通）提供的，或者你也可以手动设置为公共DNS，如Google的 8.8.8.8 或Cloudflare的 1.1.1.1。 根域名服务器：本地DNS服务器向全世界仅有的13组根服务器之一发问：“你好，请问谁管 .com 这个域？”根服务器不认识google.com，但它会告诉本地DNS：“我不知道，但你可以去问管 .com 的顶级域名（TLD）服务器，它的地址是XXX。” 顶级域名(TLD)服务器：本地DNS服务器拿着地址，又去问.com的TLD服务器：“你好，请问谁管 google.com 这个域？”TLD服务器也不认识www.google.com，但它会回复：“我不知道，但google.com的**权威域名服务器（Authoritative Name Server）**地址是XXX，它知道所有关于google.com的事情。” 权威域名服务器：本地DNS服务器终于找到了“正主”——Google自己的DNS服务器。它发起最后的询问：“你好，请问 www.google.com 的IP地址是什么？”权威服务器给出最终答案：“它的IP地址是 XXX。” 返回与缓存：本地DNS服务器拿到IP地址后，立刻告诉你的电脑，并把它缓存起来（记录一段时间，这个时间叫TTL - Time To Live），以便下次再有请求时可以直接回答。 DNS是网络攻击的重灾区，因为它处于网络访问的最前端。\nDNS欺骗/缓存投毒: 攻击者通过技术手段，向本地DNS服务器的缓存中注入一个错误的IP地址（例如，将www.mybank.com指向一个钓鱼网站的IP）。当用户访问该域名时，就会被不知不觉地引导至假冒网站。\nDNS劫持: 比投毒更严重，攻击者直接控制了你的本地DNS服务器或修改了你的网络设置，将所有DNS查询都引导至他控制的恶意服务器。\nDNS隧道: 一种隐蔽的数据泄露技术。攻击者在受控的电脑上，将窃取的数据伪装成DNS查询，通过正常的DNS协议向外发送，从而绕过防火墙的检测。\nHTTP（超文本传输协议） HTTP (Hypertext Transfer Protocol) 是一个典型的请求-响应协议。它定义了客户端（你的浏览器）如何向服务器请求数据，以及服务器如何将数据（如网页、图片、视频）传送给客户端。\n重要特性：HTTP是无状态的。这意味着服务器不会记录前一次请求的任何信息。你连续两次请求同一个页面，对于服务器来说都是全新的、独立的请求。为了解决这个问题，后来引入了 Cookie 等技术来跟踪用户会话。\nHTTP 请求 它主要包含：\n请求方法: GET或POST 路径: 你想要的具体资源，如 /products/index.html。 HTTP 版本 请求头: 一些附加信息。 Host: www.example.com: 要访问的主机名。 User-Agent: Mozilla/5.0 ...: 告诉服务器你的浏览器类型和版本。 Cookie: session-id=xyz123...: 把之前服务器给你的“身份证”再带回去。 HTTP 响应 HTTP 版本 状态码：一个三位数代码，告诉浏览器请求的结果如何。 2xx (成功): 200 OK (请求成功) 3xx (重定向): 301 Moved Permanently (你要的资源永久搬家了，请去新地址) 4xx (客户端错误): 404 Not Found (服务器上找不到你要的资源), 403 Forbidden (你没权限访问) 5xx (服务器错误): 500 Internal Server Error (服务器内部出错了) 响应头：一些附加信息。 Content-Type: text/html: 告诉浏览器我给你的是一个HTML文档。 Set-Cookie: user=jason: 指示浏览器“请记下这个信息，下次再带过来”。 响应体：实际的资源内容，如HTML代码、图片数据等。 HTTPS: 更安全的HTTP HTTP传输的所有内容都是明文的。这意味着在任何中间环节（如公共Wi-Fi），攻击者都可以窃听甚至篡改你和服务器之间的通信内容。\nHTTPS = HTTP + SSL/TLS (安全套接字层/传输层安全协议)。它在HTTP和TCP之间增加了一个加密层，提供了三大安全保障：\n加密：所有数据都被加密，中间人无法窃听。 认证：通过SSL证书，验证你所访问的服务器确实是它声称的那个，防止钓鱼网站。 完整性：确保数据在传输过程中没有被篡改。 ","wordCount":"201","inLanguage":"en","datePublished":"2025-07-01T11:49:25+08:00","dateModified":"2025-07-01T11:49:25+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://evan704.github.io/posts/networking-fundamentals/"},"publisher":{"@type":"Organization","name":"Evan's blog","logo":{"@type":"ImageObject","url":"https://evan704.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://evan704.github.io/ accesskey=h title="Evan's blog (Alt + H)">Evan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://evan704.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://evan704.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://evan704.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://evan704.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://evan704.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">网络基础</h1><div class=post-meta><span title='2025-07-01 11:49:25 +0800 +0800'>July 1, 2025</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ip%e5%9c%b0%e5%9d%80%e5%ad%90%e7%bd%91%e6%8e%a9%e7%a0%81 aria-label=IP地址&子网掩码>IP地址&子网掩码</a></li><li><a href=#%e5%ad%90%e7%bd%91%e5%88%92%e5%88%86 aria-label=子网划分>子网划分</a></li><li><a href=#tcp-%e4%b8%8e-udp aria-label="TCP 与 UDP">TCP 与 UDP</a><ul><li><a href=#tcp-transmission-control-protocol---%e5%8f%af%e9%9d%a0%e7%9a%84%e4%bf%a1%e4%bd%bf aria-label="TCP (Transmission Control Protocol) - 可靠的信使">TCP (Transmission Control Protocol) - 可靠的信使</a></li><li><a href=#udp-user-datagram-protocol---%e8%bf%85%e6%8d%b7%e7%9a%84%e4%bf%a1%e4%bd%bf aria-label="UDP (User Datagram Protocol) - 迅捷的信使">UDP (User Datagram Protocol) - 迅捷的信使</a></li><li><a href=#%e7%ab%af%e5%8f%a3 aria-label=端口>端口</a></li></ul></li><li><a href=#dns%e5%9f%9f%e5%90%8d%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label=DNS（域名服务器）>DNS（域名服务器）</a></li><li><a href=#http%e8%b6%85%e6%96%87%e6%9c%ac%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae aria-label=HTTP（超文本传输协议）>HTTP（超文本传输协议）</a><ul><li><a href=#http-%e8%af%b7%e6%b1%82 aria-label="HTTP 请求">HTTP 请求</a></li><li><a href=#http-%e5%93%8d%e5%ba%94 aria-label="HTTP 响应">HTTP 响应</a></li></ul></li><li><a href=#https-%e6%9b%b4%e5%ae%89%e5%85%a8%e7%9a%84http aria-label="HTTPS: 更安全的HTTP">HTTPS: 更安全的HTTP</a></li></ul></div></details></div><div class=post-content><h2 id=ip地址子网掩码>IP地址&子网掩码<a hidden class=anchor aria-hidden=true href=#ip地址子网掩码>#</a></h2><ul><li><strong>IP地址</strong>：网络世界里的“门牌号”，唯一标识一台设备。最常见的是IPv4格式，如 <code>192.168.1.10</code>，它实际是一个32位的二进制数，为方便阅读写作4个十进制数（每个表示8位二进制数）。<ul><li>分类：<ul><li>公网IP (Public IP)：全球唯一，由运营商分配，可以直接在互联网上访问。</li><li>私网IP (Private IP)：在一个局域网内唯一，不能直接在互联网上访问。</li></ul></li><li>一个IP地址并非一个整体，它包含两部分信息：网络ID和主机ID。计算机如何知道哪部分是网络ID，哪部分是主机ID呢？答案是利用子网掩码。</li></ul></li><li><strong>子网掩码</strong>：用于区分网络ID和主机ID。<code>1</code>部分标识网络ID，<code>0</code>部分标识主机ID，如<code>255.255.255.0</code>表示前24位为子网地址，后8位为主机地址，也可以用<code>/24</code>表示。<ul><li>例：<ul><li>IP地址: <code>192.168.1.10</code></li><li>子网掩码: <code>255.255.255.0</code></li><li>那么网络ID是前24位：<code>192.168.1</code>，主机ID是后8位：<code>10</code>，所有192.168.1.x的设备都在同一个局域网内，它们之间可以直接通信。</li></ul></li></ul></li></ul><h2 id=子网划分>子网划分<a hidden class=anchor aria-hidden=true href=#子网划分>#</a></h2><p>想象一个有500台电脑的大公司，如果它们都在同一个局域网内，任何一台电脑发送一个广播（比如寻找打印机），所有500台电脑都会收到，网络会非常拥堵。子网划分就是将一个大的网络，切分成若干个互不干扰的小网络（子网），比如“财务部子网”、“技术部子网”。怎么实现这一点呢？我们可以通过修改子网掩码，向主机ID“借”几位，把它们变成子网ID。</p><p>举个例子，我们有一个网络<code>192.168.1.0</code>，原本的子网掩码是<code>255.255.255.0</code>，这个局域网下，我们有$2^8-2=254$个可用的主机IP。如果我们想把它们分成两个网络，我们可以向主机ID借一位，新的子网掩码就是<code>255.255.255.128</code>，这样我们就得到了两个子网，<code>192.168.1.0</code>和<code>192.168.1.128</code></p><h2 id=tcp-与-udp>TCP 与 UDP<a hidden class=anchor aria-hidden=true href=#tcp-与-udp>#</a></h2><p>TCP 和 UDP 负责将数据包送到正确的端口。</p><h3 id=tcp-transmission-control-protocol---可靠的信使>TCP (Transmission Control Protocol) - 可靠的信使<a hidden class=anchor aria-hidden=true href=#tcp-transmission-control-protocol---可靠的信使>#</a></h3><p>TCP 的特点是可靠且能进行流量控制。TCP 在发送数据前，必须先建立连接。这就是著名的“三次握手”。</p><ul><li>三次握手<ol><li><strong>客户端 -> 服务器</strong>：发送一个SYN包。&ldquo;你好，我想和你建立连接，我的初始序列号是X。&rdquo;</li><li><strong>服务器 -> 客户端</strong>：回复一个SYN/ACK包。&ldquo;好的，我收到了你的请求。我同意连接，我的初始序列号是Y，我确认收到了你的序列号X。&rdquo;</li><li><strong>客户端 -> 服务器</strong>：再次发送一个ACK包。&ldquo;好的，我收到了你的确认。现在连接正式建立，我们可以开始通信了。&rdquo;</li></ol></li></ul><h3 id=udp-user-datagram-protocol---迅捷的信使>UDP (User Datagram Protocol) - 迅捷的信使<a hidden class=anchor aria-hidden=true href=#udp-user-datagram-protocol---迅捷的信使>#</a></h3><p>UDP 的特点是不一定可靠，但速度更快。UDP 在发送数据前不需要建立连接，直接发送。它的适用场景是对实时性要求高，但能容忍少量丢包的场景，比如视频直播和在线游戏。</p><h3 id=端口>端口<a hidden class=anchor aria-hidden=true href=#端口>#</a></h3><p>端口的作用是区分一台主机上的不同应用。IP地址让数据找到电脑，端口号让数据找到正确的程序。范围：<code>0</code> - <code>65535</code>。</p><p>常见端口：</p><ul><li>FTP: 21 (TCP)</li><li>SSH: 22 (TCP)</li><li>SMTP: 25 (TCP)</li><li>DNS: 53 (UDP为主，TCP为辅)</li><li>HTTP: 80 (TCP)</li><li>HTTPS: 443 (TCP)</li></ul><h2 id=dns域名服务器>DNS（域名服务器）<a hidden class=anchor aria-hidden=true href=#dns域名服务器>#</a></h2><p>计算机在网络中互相寻找，靠的是IP地址（如<code>142.250.72.142</code>）。但人类显然更擅长记忆名字（如<code>www.google.com</code>）。DNS (Domain Name System) 的核心使命，就是负责在这两者之间进行<strong>双向翻译</strong>。</p><p>当你输入一个网址时，你的电脑并不知道www.google.com在哪里。它必须先通过DNS查询，获得其对应的IP地址，然后才能向该IP地址发起网络连接。</p><p>一次完整的域名解析过程如下：</p><ol><li>本机缓存：的电脑会先检查自己的“小本本”（DNS缓存）：“我最近查过这个域名吗？”。如果查过且没过期，就直接使用缓存的IP地址，查询结束。同时，它也会检查一个特殊的hosts文件，这个文件允许你手动指定域名和IP的对应关系，优先级很高。</li><li>本地DNS服务器：如果本机没有缓存，请求会被发往你的本地DNS服务器。这通常是你的ISP（运营商，如电信、联通）提供的，或者你也可以手动设置为公共DNS，如Google的 <code>8.8.8.8</code> 或Cloudflare的 <code>1.1.1.1</code>。</li><li>根域名服务器：本地DNS服务器向全世界仅有的13组根服务器之一发问：“你好，请问谁管 <code>.com</code> 这个域？”根服务器不认识<code>google.com</code>，但它会告诉本地DNS：“我不知道，但你可以去问管 <code>.com</code> 的顶级域名（TLD）服务器，它的地址是XXX。”</li><li>顶级域名(TLD)服务器：本地DNS服务器拿着地址，又去问<code>.com</code>的TLD服务器：“你好，请问谁管 <code>google.com</code> 这个域？”TLD服务器也不认识<code>www.google.com</code>，但它会回复：“我不知道，但<code>google.com</code>的**权威域名服务器（Authoritative Name Server）**地址是XXX，它知道所有关于<code>google.com</code>的事情。”</li><li>权威域名服务器：本地DNS服务器终于找到了“正主”——Google自己的DNS服务器。它发起最后的询问：“你好，请问 <code>www.google.com</code> 的IP地址是什么？”权威服务器给出最终答案：“它的IP地址是 XXX。”</li><li>返回与缓存：本地DNS服务器拿到IP地址后，立刻告诉你的电脑，并把它缓存起来（记录一段时间，这个时间叫TTL - Time To Live），以便下次再有请求时可以直接回答。</li></ol><p>DNS是网络攻击的重灾区，因为它处于网络访问的最前端。</p><ul><li><p>DNS欺骗/缓存投毒: 攻击者通过技术手段，向本地DNS服务器的缓存中注入一个错误的IP地址（例如，将<code>www.mybank.com</code>指向一个钓鱼网站的IP）。当用户访问该域名时，就会被不知不觉地引导至假冒网站。</p></li><li><p>DNS劫持: 比投毒更严重，攻击者直接控制了你的本地DNS服务器或修改了你的网络设置，将所有DNS查询都引导至他控制的恶意服务器。</p></li><li><p>DNS隧道: 一种隐蔽的数据泄露技术。攻击者在受控的电脑上，将窃取的数据伪装成DNS查询，通过正常的DNS协议向外发送，从而绕过防火墙的检测。</p></li></ul><h2 id=http超文本传输协议>HTTP（超文本传输协议）<a hidden class=anchor aria-hidden=true href=#http超文本传输协议>#</a></h2><p>HTTP (Hypertext Transfer Protocol) 是一个典型的<strong>请求-响应协议</strong>。它定义了客户端（你的浏览器）如何向服务器请求数据，以及服务器如何将数据（如网页、图片、视频）传送给客户端。</p><p><strong>重要特性</strong>：HTTP是<strong>无状态</strong>的。这意味着服务器不会记录前一次请求的任何信息。你连续两次请求同一个页面，对于服务器来说都是全新的、独立的请求。为了解决这个问题，后来引入了 Cookie 等技术来跟踪用户会话。</p><h3 id=http-请求>HTTP 请求<a hidden class=anchor aria-hidden=true href=#http-请求>#</a></h3><p>它主要包含：</p><ol><li><strong>请求方法</strong>: <code>GET</code>或<code>POST</code></li><li><strong>路径</strong>: 你想要的具体资源，如 <code>/products/index.html</code>。</li><li><strong>HTTP 版本</strong></li><li><strong>请求头</strong>: 一些附加信息。<ul><li><code>Host: www.example.com</code>: 要访问的主机名。</li><li><code>User-Agent: Mozilla/5.0 ...</code>: 告诉服务器你的浏览器类型和版本。</li><li><code>Cookie: session-id=xyz123...</code>: 把之前服务器给你的“身份证”再带回去。</li></ul></li></ol><h3 id=http-响应>HTTP 响应<a hidden class=anchor aria-hidden=true href=#http-响应>#</a></h3><ol><li><strong>HTTP 版本</strong></li><li><strong>状态码</strong>：一个三位数代码，告诉浏览器请求的结果如何。<ul><li><code>2xx</code> (成功): <code>200 OK</code> (请求成功)</li><li><code>3xx</code> (重定向): <code>301 Moved Permanently</code> (你要的资源永久搬家了，请去新地址)</li><li><code>4xx</code> (客户端错误): <code>404 Not Found</code> (服务器上找不到你要的资源), <code>403 Forbidden</code> (你没权限访问)</li><li><code>5xx</code> (服务器错误): <code>500 Internal Server Error</code> (服务器内部出错了)</li></ul></li><li><strong>响应头</strong>：一些附加信息。<ul><li><code>Content-Type: text/html</code>: 告诉浏览器我给你的是一个HTML文档。</li><li><code>Set-Cookie: user=jason</code>: 指示浏览器“请记下这个信息，下次再带过来”。</li></ul></li><li><strong>响应体</strong>：实际的资源内容，如HTML代码、图片数据等。</li></ol><h2 id=https-更安全的http>HTTPS: 更安全的HTTP<a hidden class=anchor aria-hidden=true href=#https-更安全的http>#</a></h2><p>HTTP传输的所有内容都是<strong>明文</strong>的。这意味着在任何中间环节（如公共Wi-Fi），攻击者都可以窃听甚至篡改你和服务器之间的通信内容。</p><p><strong>HTTPS = HTTP + SSL/TLS</strong> (安全套接字层/传输层安全协议)。它在HTTP和TCP之间增加了一个加密层，提供了三大安全保障：</p><ul><li><strong>加密</strong>：所有数据都被加密，中间人无法窃听。</li><li><strong>认证</strong>：通过SSL证书，验证你所访问的服务器确实是它声称的那个，防止钓鱼网站。</li><li><strong>完整性</strong>：确保数据在传输过程中没有被篡改。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://evan704.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a></li><li><a href=https://evan704.github.io/tags/basics/>Basics</a></li></ul><nav class=paginav><a class=prev href=https://evan704.github.io/posts/nmap-basic-usage/><span class=title>« Prev</span><br><span>[网络安全] nmap 基础</span>
</a><a class=next href=https://evan704.github.io/posts/linux-basic-command-file-and-directory/><span class=title>Next »</span><br><span>[Linux基础命令] 文件与目录管理</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://evan704.github.io/>Evan's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=/js/copy.js defer></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>